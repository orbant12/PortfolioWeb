import {
  require_LexicalComposerContext
} from "./chunk-2PR6ICWI.js";
import {
  require_react
} from "./chunk-4D5CYJYK.js";
import {
  require_LexicalMarkdown
} from "./chunk-LJKAH7TI.js";
import "./chunk-47T7ESIR.js";
import "./chunk-UBGXKGIU.js";
import "./chunk-BGHPDTY4.js";
import "./chunk-MVFM7TSA.js";
import "./chunk-MZSCO3Q7.js";
import {
  require_LexicalUtils
} from "./chunk-DBG3QTGS.js";
import "./chunk-26HJLANE.js";
import {
  require_Lexical
} from "./chunk-OOMKOIZE.js";
import {
  __commonJS
} from "./chunk-CEQRFMJQ.js";

// node_modules/@lexical/react/useLexicalNodeSelection.dev.js
var require_useLexicalNodeSelection_dev = __commonJS({
  "node_modules/@lexical/react/useLexicalNodeSelection.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var lexical = require_Lexical();
    var react = require_react();
    function isNodeSelected(editor, key) {
      return editor.getEditorState().read(() => {
        const node = lexical.$getNodeByKey(key);
        if (node === null) {
          return false;
        }
        return node.isSelected();
      });
    }
    function useLexicalNodeSelection(key) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const [isSelected, setIsSelected] = react.useState(() => isNodeSelected(editor, key));
      react.useEffect(() => {
        let isMounted = true;
        const unregister = editor.registerUpdateListener(() => {
          if (isMounted) {
            setIsSelected(isNodeSelected(editor, key));
          }
        });
        return () => {
          isMounted = false;
          unregister();
        };
      }, [editor, key]);
      const setSelected = react.useCallback((selected) => {
        editor.update(() => {
          let selection = lexical.$getSelection();
          if (!lexical.$isNodeSelection(selection)) {
            selection = lexical.$createNodeSelection();
            lexical.$setSelection(selection);
          }
          if (lexical.$isNodeSelection(selection)) {
            if (selected) {
              selection.add(key);
            } else {
              selection.delete(key);
            }
          }
        });
      }, [editor, key]);
      const clearSelected = react.useCallback(() => {
        editor.update(() => {
          const selection = lexical.$getSelection();
          if (lexical.$isNodeSelection(selection)) {
            selection.clear();
          }
        });
      }, [editor]);
      return [isSelected, setSelected, clearSelected];
    }
    exports.useLexicalNodeSelection = useLexicalNodeSelection;
  }
});

// node_modules/@lexical/react/useLexicalNodeSelection.js
var require_useLexicalNodeSelection = __commonJS({
  "node_modules/@lexical/react/useLexicalNodeSelection.js"(exports, module) {
    "use strict";
    var useLexicalNodeSelection = true ? require_useLexicalNodeSelection_dev() : null;
    module.exports = useLexicalNodeSelection;
  }
});

// node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js
var require_LexicalHorizontalRuleNode_dev = __commonJS({
  "node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var useLexicalNodeSelection = require_useLexicalNodeSelection();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    var React = require_react();
    var INSERT_HORIZONTAL_RULE_COMMAND = lexical.createCommand("INSERT_HORIZONTAL_RULE_COMMAND");
    function HorizontalRuleComponent({
      nodeKey
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection.useLexicalNodeSelection(nodeKey);
      const onDelete = React.useCallback((event) => {
        if (isSelected && lexical.$isNodeSelection(lexical.$getSelection())) {
          event.preventDefault();
          const node = lexical.$getNodeByKey(nodeKey);
          if ($isHorizontalRuleNode(node)) {
            node.remove();
          }
        }
        return false;
      }, [isSelected, nodeKey]);
      React.useEffect(() => {
        return utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, (event) => {
          const hrElem = editor.getElementByKey(nodeKey);
          if (event.target === hrElem) {
            if (!event.shiftKey) {
              clearSelection();
            }
            setSelected(!isSelected);
            return true;
          }
          return false;
        }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_DELETE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW));
      }, [clearSelection, editor, isSelected, nodeKey, onDelete, setSelected]);
      React.useEffect(() => {
        const hrElem = editor.getElementByKey(nodeKey);
        if (hrElem !== null) {
          hrElem.className = isSelected ? "selected" : "";
        }
      }, [editor, isSelected, nodeKey]);
      return null;
    }
    var HorizontalRuleNode = class _HorizontalRuleNode extends lexical.DecoratorNode {
      static getType() {
        return "horizontalrule";
      }
      static clone(node) {
        return new _HorizontalRuleNode(node.__key);
      }
      static importJSON(serializedNode) {
        return $createHorizontalRuleNode();
      }
      static importDOM() {
        return {
          hr: () => ({
            conversion: convertHorizontalRuleElement,
            priority: 0
          })
        };
      }
      exportJSON() {
        return {
          type: "horizontalrule",
          version: 1
        };
      }
      exportDOM() {
        return {
          element: document.createElement("hr")
        };
      }
      createDOM() {
        return document.createElement("hr");
      }
      getTextContent() {
        return "\n";
      }
      isInline() {
        return false;
      }
      updateDOM() {
        return false;
      }
      decorate() {
        return React.createElement(HorizontalRuleComponent, {
          nodeKey: this.__key
        });
      }
    };
    function convertHorizontalRuleElement() {
      return {
        node: $createHorizontalRuleNode()
      };
    }
    function $createHorizontalRuleNode() {
      return lexical.$applyNodeReplacement(new HorizontalRuleNode());
    }
    function $isHorizontalRuleNode(node) {
      return node instanceof HorizontalRuleNode;
    }
    exports.$createHorizontalRuleNode = $createHorizontalRuleNode;
    exports.$isHorizontalRuleNode = $isHorizontalRuleNode;
    exports.HorizontalRuleNode = HorizontalRuleNode;
    exports.INSERT_HORIZONTAL_RULE_COMMAND = INSERT_HORIZONTAL_RULE_COMMAND;
  }
});

// node_modules/@lexical/react/LexicalHorizontalRuleNode.js
var require_LexicalHorizontalRuleNode = __commonJS({
  "node_modules/@lexical/react/LexicalHorizontalRuleNode.js"(exports, module) {
    "use strict";
    var LexicalHorizontalRuleNode = true ? require_LexicalHorizontalRuleNode_dev() : null;
    module.exports = LexicalHorizontalRuleNode;
  }
});

// node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js
var require_LexicalMarkdownShortcutPlugin_dev = __commonJS({
  "node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js"(exports) {
    "use strict";
    var markdown = require_LexicalMarkdown();
    var LexicalComposerContext = require_LexicalComposerContext();
    var LexicalHorizontalRuleNode = require_LexicalHorizontalRuleNode();
    var react = require_react();
    var HR = {
      dependencies: [LexicalHorizontalRuleNode.HorizontalRuleNode],
      export: (node) => {
        return LexicalHorizontalRuleNode.$isHorizontalRuleNode(node) ? "***" : null;
      },
      regExp: /^(---|\*\*\*|___)\s?$/,
      replace: (parentNode, _1, _2, isImport) => {
        const line = LexicalHorizontalRuleNode.$createHorizontalRuleNode();
        if (isImport || parentNode.getNextSibling() != null) {
          parentNode.replace(line);
        } else {
          parentNode.insertBefore(line);
        }
        line.selectNext();
      },
      type: "element"
    };
    var DEFAULT_TRANSFORMERS = [HR, ...markdown.TRANSFORMERS];
    function MarkdownShortcutPlugin({
      transformers = DEFAULT_TRANSFORMERS
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      react.useEffect(() => {
        return markdown.registerMarkdownShortcuts(editor, transformers);
      }, [editor, transformers]);
      return null;
    }
    exports.DEFAULT_TRANSFORMERS = DEFAULT_TRANSFORMERS;
    exports.MarkdownShortcutPlugin = MarkdownShortcutPlugin;
  }
});

// node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js
var require_LexicalMarkdownShortcutPlugin = __commonJS({
  "node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js"(exports, module) {
    var LexicalMarkdownShortcutPlugin = true ? require_LexicalMarkdownShortcutPlugin_dev() : null;
    module.exports = LexicalMarkdownShortcutPlugin;
  }
});
export default require_LexicalMarkdownShortcutPlugin();
//# sourceMappingURL=@lexical_react_LexicalMarkdownShortcutPlugin.js.map
