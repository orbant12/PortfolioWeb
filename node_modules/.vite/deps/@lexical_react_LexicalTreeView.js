import {
  require_LexicalHtml
} from "./chunk-UBGXKGIU.js";
import {
  require_LexicalLink
} from "./chunk-MZSCO3Q7.js";
import {
  require_LexicalUtils
} from "./chunk-DBG3QTGS.js";
import "./chunk-26HJLANE.js";
import {
  require_Lexical
} from "./chunk-OOMKOIZE.js";
import {
  require_react
} from "./chunk-4D5CYJYK.js";
import {
  __commonJS
} from "./chunk-CEQRFMJQ.js";

// node_modules/@lexical/mark/LexicalMark.dev.js
var require_LexicalMark_dev = __commonJS({
  "node_modules/@lexical/mark/LexicalMark.dev.js"(exports) {
    "use strict";
    var lexical = require_Lexical();
    var utils = require_LexicalUtils();
    var MarkNode = class _MarkNode extends lexical.ElementNode {
      /** @internal */
      static getType() {
        return "mark";
      }
      static clone(node) {
        return new _MarkNode(Array.from(node.__ids), node.__key);
      }
      static importDOM() {
        return null;
      }
      static importJSON(serializedNode) {
        const node = $createMarkNode(serializedNode.ids);
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          ids: this.getIDs(),
          type: "mark",
          version: 1
        };
      }
      constructor(ids, key) {
        super(key);
        this.__ids = ids || [];
      }
      createDOM(config) {
        const element = document.createElement("mark");
        utils.addClassNamesToElement(element, config.theme.mark);
        if (this.__ids.length > 1) {
          utils.addClassNamesToElement(element, config.theme.markOverlap);
        }
        return element;
      }
      updateDOM(prevNode, element, config) {
        const prevIDs = prevNode.__ids;
        const nextIDs = this.__ids;
        const prevIDsCount = prevIDs.length;
        const nextIDsCount = nextIDs.length;
        const overlapTheme = config.theme.markOverlap;
        if (prevIDsCount !== nextIDsCount) {
          if (prevIDsCount === 1) {
            if (nextIDsCount === 2) {
              utils.addClassNamesToElement(element, overlapTheme);
            }
          } else if (nextIDsCount === 1) {
            utils.removeClassNamesFromElement(element, overlapTheme);
          }
        }
        return false;
      }
      hasID(id) {
        const ids = this.getIDs();
        for (let i = 0; i < ids.length; i++) {
          if (id === ids[i]) {
            return true;
          }
        }
        return false;
      }
      getIDs() {
        const self = this.getLatest();
        return $isMarkNode(self) ? self.__ids : [];
      }
      addID(id) {
        const self = this.getWritable();
        if ($isMarkNode(self)) {
          const ids = self.__ids;
          self.__ids = ids;
          for (let i = 0; i < ids.length; i++) {
            if (id === ids[i])
              return;
          }
          ids.push(id);
        }
      }
      deleteID(id) {
        const self = this.getWritable();
        if ($isMarkNode(self)) {
          const ids = self.__ids;
          self.__ids = ids;
          for (let i = 0; i < ids.length; i++) {
            if (id === ids[i]) {
              ids.splice(i, 1);
              return;
            }
          }
        }
      }
      insertNewAfter(selection, restoreSelection = true) {
        const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);
        if (lexical.$isElementNode(element)) {
          const markNode = $createMarkNode(this.__ids);
          element.append(markNode);
          return markNode;
        }
        return null;
      }
      canInsertTextBefore() {
        return false;
      }
      canInsertTextAfter() {
        return false;
      }
      canBeEmpty() {
        return false;
      }
      isInline() {
        return true;
      }
      extractWithChild(child, selection, destination) {
        if (!lexical.$isRangeSelection(selection) || destination === "html") {
          return false;
        }
        const anchor = selection.anchor;
        const focus = selection.focus;
        const anchorNode = anchor.getNode();
        const focusNode = focus.getNode();
        const isBackward = selection.isBackward();
        const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;
        return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;
      }
      excludeFromCopy(destination) {
        return destination !== "clone";
      }
    };
    function $createMarkNode(ids) {
      return lexical.$applyNodeReplacement(new MarkNode(ids));
    }
    function $isMarkNode(node) {
      return node instanceof MarkNode;
    }
    function $unwrapMarkNode(node) {
      const children = node.getChildren();
      let target = null;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (target === null) {
          node.insertBefore(child);
        } else {
          target.insertAfter(child);
        }
        target = child;
      }
      node.remove();
    }
    function $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {
      const nodes = selection.getNodes();
      const anchorOffset = selection.anchor.offset;
      const focusOffset = selection.focus.offset;
      const nodesLength = nodes.length;
      const startOffset = isBackward ? focusOffset : anchorOffset;
      const endOffset = isBackward ? anchorOffset : focusOffset;
      let currentNodeParent;
      let lastCreatedMarkNode;
      for (let i = 0; i < nodesLength; i++) {
        const node = nodes[i];
        if (lexical.$isElementNode(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {
          continue;
        }
        const isFirstNode = i === 0;
        const isLastNode = i === nodesLength - 1;
        let targetNode = null;
        if (lexical.$isTextNode(node)) {
          const textContentSize = node.getTextContentSize();
          const startTextOffset = isFirstNode ? startOffset : 0;
          const endTextOffset = isLastNode ? endOffset : textContentSize;
          if (startTextOffset === 0 && endTextOffset === 0) {
            continue;
          }
          const splitNodes = node.splitText(startTextOffset, endTextOffset);
          targetNode = splitNodes.length > 1 && (splitNodes.length === 3 || isFirstNode && !isLastNode || endTextOffset === textContentSize) ? splitNodes[1] : splitNodes[0];
        } else if ($isMarkNode(node)) {
          continue;
        } else if (lexical.$isElementNode(node) && node.isInline()) {
          targetNode = node;
        }
        if (targetNode !== null) {
          if (targetNode && targetNode.is(currentNodeParent)) {
            continue;
          }
          const parentNode = targetNode.getParent();
          if (parentNode == null || !parentNode.is(currentNodeParent)) {
            lastCreatedMarkNode = void 0;
          }
          currentNodeParent = parentNode;
          if (lastCreatedMarkNode === void 0) {
            const createMarkNode = createNode || $createMarkNode;
            lastCreatedMarkNode = createMarkNode([id]);
            targetNode.insertBefore(lastCreatedMarkNode);
          }
          lastCreatedMarkNode.append(targetNode);
        } else {
          currentNodeParent = void 0;
          lastCreatedMarkNode = void 0;
        }
      }
      if (lexical.$isElementNode(lastCreatedMarkNode)) {
        isBackward ? lastCreatedMarkNode.selectStart() : lastCreatedMarkNode.selectEnd();
      }
    }
    function $getMarkIDs(node, offset) {
      let currentNode = node;
      while (currentNode !== null) {
        if ($isMarkNode(currentNode)) {
          return currentNode.getIDs();
        } else if (lexical.$isTextNode(currentNode) && offset === currentNode.getTextContentSize()) {
          const nextSibling = currentNode.getNextSibling();
          if ($isMarkNode(nextSibling)) {
            return nextSibling.getIDs();
          }
        }
        currentNode = currentNode.getParent();
      }
      return null;
    }
    exports.$createMarkNode = $createMarkNode;
    exports.$getMarkIDs = $getMarkIDs;
    exports.$isMarkNode = $isMarkNode;
    exports.$unwrapMarkNode = $unwrapMarkNode;
    exports.$wrapSelectionInMarkNode = $wrapSelectionInMarkNode;
    exports.MarkNode = MarkNode;
  }
});

// node_modules/@lexical/mark/LexicalMark.js
var require_LexicalMark = __commonJS({
  "node_modules/@lexical/mark/LexicalMark.js"(exports, module) {
    "use strict";
    var LexicalMark = true ? require_LexicalMark_dev() : null;
    module.exports = LexicalMark;
  }
});

// node_modules/@lexical/react/LexicalTreeView.dev.js
var require_LexicalTreeView_dev = __commonJS({
  "node_modules/@lexical/react/LexicalTreeView.dev.js"(exports) {
    "use strict";
    var html = require_LexicalHtml();
    var link = require_LexicalLink();
    var mark = require_LexicalMark();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    var React = require_react();
    var NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({
      "	": "\\t",
      "\n": "\\n"
    });
    var NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join("|"), "g");
    var SYMBOLS = Object.freeze({
      ancestorHasNextSibling: "|",
      ancestorIsLastChild: " ",
      hasNextSibling: "├",
      isLastChild: "└",
      selectedChar: "^",
      selectedLine: ">"
    });
    function TreeView({
      treeTypeButtonClassName,
      timeTravelButtonClassName,
      timeTravelPanelSliderClassName,
      timeTravelPanelButtonClassName,
      viewClassName,
      timeTravelPanelClassName,
      editor
    }) {
      const [timeStampedEditorStates, setTimeStampedEditorStates] = React.useState([]);
      const [content, setContent] = React.useState("");
      const [timeTravelEnabled, setTimeTravelEnabled] = React.useState(false);
      const [showExportDOM, setShowExportDOM] = React.useState(false);
      const playingIndexRef = React.useRef(0);
      const treeElementRef = React.useRef(null);
      const inputRef = React.useRef(null);
      const [isPlaying, setIsPlaying] = React.useState(false);
      const [isLimited, setIsLimited] = React.useState(false);
      const [showLimited, setShowLimited] = React.useState(false);
      const lastEditorStateRef = React.useRef(null);
      const commandsLog = useLexicalCommandsLog(editor);
      const generateTree = React.useCallback((editorState) => {
        const treeText = generateContent(editor, commandsLog, showExportDOM);
        setContent(treeText);
        if (!timeTravelEnabled) {
          setTimeStampedEditorStates((currentEditorStates) => [...currentEditorStates, [Date.now(), editorState]]);
        }
      }, [commandsLog, editor, timeTravelEnabled, showExportDOM]);
      React.useEffect(() => {
        const editorState = editor.getEditorState();
        if (!showLimited && editorState._nodeMap.size < 1e3) {
          setContent(generateContent(editor, commandsLog, showExportDOM));
        }
      }, [commandsLog, editor, showLimited, showExportDOM]);
      React.useEffect(() => {
        return utils.mergeRegister(editor.registerUpdateListener(({
          editorState
        }) => {
          if (!showLimited && editorState._nodeMap.size > 1e3) {
            lastEditorStateRef.current = editorState;
            setIsLimited(true);
            if (!showLimited) {
              return;
            }
          }
          generateTree(editorState);
        }), editor.registerEditableListener(() => {
          const treeText = generateContent(editor, commandsLog, showExportDOM);
          setContent(treeText);
        }));
      }, [commandsLog, editor, showExportDOM, isLimited, generateTree, showLimited]);
      const totalEditorStates = timeStampedEditorStates.length;
      React.useEffect(() => {
        if (isPlaying) {
          let timeoutId;
          const play = () => {
            const currentIndex = playingIndexRef.current;
            if (currentIndex === totalEditorStates - 1) {
              setIsPlaying(false);
              return;
            }
            const currentTime = timeStampedEditorStates[currentIndex][0];
            const nextTime = timeStampedEditorStates[currentIndex + 1][0];
            const timeDiff = nextTime - currentTime;
            timeoutId = setTimeout(() => {
              playingIndexRef.current++;
              const index = playingIndexRef.current;
              const input = inputRef.current;
              if (input !== null) {
                input.value = String(index);
              }
              editor.setEditorState(timeStampedEditorStates[index][1]);
              play();
            }, timeDiff);
          };
          play();
          return () => {
            clearTimeout(timeoutId);
          };
        }
      }, [timeStampedEditorStates, isPlaying, editor, totalEditorStates]);
      React.useEffect(() => {
        const element = treeElementRef.current;
        if (element !== null) {
          element.__lexicalEditor = editor;
          return () => {
            element.__lexicalEditor = null;
          };
        }
      }, [editor]);
      return React.createElement("div", {
        className: viewClassName
      }, !showLimited && isLimited ? React.createElement("div", {
        style: {
          padding: 20
        }
      }, React.createElement("span", {
        style: {
          marginRight: 20
        }
      }, "Detected large EditorState, this can impact debugging performance."), React.createElement("button", {
        onClick: () => {
          setShowLimited(true);
          const editorState = lastEditorStateRef.current;
          if (editorState !== null) {
            lastEditorStateRef.current = null;
            generateTree(editorState);
          }
        },
        style: {
          background: "transparent",
          border: "1px solid white",
          color: "white",
          cursor: "pointer",
          padding: 5
        }
      }, "Show full tree")) : null, !showLimited ? React.createElement("button", {
        onClick: () => setShowExportDOM(!showExportDOM),
        className: treeTypeButtonClassName,
        type: "button"
      }, showExportDOM ? "Tree" : "Export DOM") : null, !timeTravelEnabled && (showLimited || !isLimited) && totalEditorStates > 2 && React.createElement("button", {
        onClick: () => {
          const rootElement = editor.getRootElement();
          if (rootElement !== null) {
            rootElement.contentEditable = "false";
            playingIndexRef.current = totalEditorStates - 1;
            setTimeTravelEnabled(true);
          }
        },
        className: timeTravelButtonClassName,
        type: "button"
      }, "Time Travel"), (showLimited || !isLimited) && React.createElement("pre", {
        ref: treeElementRef
      }, content), timeTravelEnabled && (showLimited || !isLimited) && React.createElement("div", {
        className: timeTravelPanelClassName
      }, React.createElement("button", {
        className: timeTravelPanelButtonClassName,
        onClick: () => {
          if (playingIndexRef.current === totalEditorStates - 1) {
            playingIndexRef.current = 1;
          }
          setIsPlaying(!isPlaying);
        },
        type: "button"
      }, isPlaying ? "Pause" : "Play"), React.createElement("input", {
        className: timeTravelPanelSliderClassName,
        ref: inputRef,
        onChange: (event) => {
          const editorStateIndex = Number(event.target.value);
          const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];
          if (timeStampedEditorState) {
            playingIndexRef.current = editorStateIndex;
            editor.setEditorState(timeStampedEditorState[1]);
          }
        },
        type: "range",
        min: "1",
        max: totalEditorStates - 1
      }), React.createElement("button", {
        className: timeTravelPanelButtonClassName,
        onClick: () => {
          const rootElement = editor.getRootElement();
          if (rootElement !== null) {
            rootElement.contentEditable = "true";
            const index = timeStampedEditorStates.length - 1;
            const timeStampedEditorState = timeStampedEditorStates[index];
            editor.setEditorState(timeStampedEditorState[1]);
            const input = inputRef.current;
            if (input !== null) {
              input.value = String(index);
            }
            setTimeTravelEnabled(false);
            setIsPlaying(false);
          }
        },
        type: "button"
      }, "Exit")));
    }
    function useLexicalCommandsLog(editor) {
      const [loggedCommands, setLoggedCommands] = React.useState([]);
      React.useEffect(() => {
        const unregisterCommandListeners = /* @__PURE__ */ new Set();
        for (const [command] of editor._commands) {
          unregisterCommandListeners.add(editor.registerCommand(command, (payload) => {
            setLoggedCommands((state) => {
              const newState = [...state];
              newState.push({
                payload,
                type: command.type ? command.type : "UNKNOWN"
              });
              if (newState.length > 10) {
                newState.shift();
              }
              return newState;
            });
            return false;
          }, lexical.COMMAND_PRIORITY_HIGH));
        }
        return () => unregisterCommandListeners.forEach((unregister) => unregister());
      }, [editor]);
      return React.useMemo(() => loggedCommands, [loggedCommands]);
    }
    function printRangeSelection(selection) {
      let res = "";
      const formatText = printFormatProperties(selection);
      res += `: range ${formatText !== "" ? `{ ${formatText} }` : ""} ${selection.style !== "" ? `{ style: ${selection.style} } ` : ""}`;
      const anchor = selection.anchor;
      const focus = selection.focus;
      const anchorOffset = anchor.offset;
      const focusOffset = focus.offset;
      res += `
  ├ anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? "null" : anchorOffset}, type: ${anchor.type} }`;
      res += `
  └ focus { key: ${focus.key}, offset: ${focusOffset === null ? "null" : focusOffset}, type: ${focus.type} }`;
      return res;
    }
    function printNodeSelection(selection) {
      if (!lexical.$isNodeSelection(selection))
        return "";
      return `: node
  └ [${Array.from(selection._nodes).join(", ")}]`;
    }
    function printGridSelection(selection) {
      return `: grid
  └ { grid: ${selection.gridKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;
    }
    function generateContent(editor, commandsLog, exportDOM) {
      const editorState = editor.getEditorState();
      const editorConfig = editor._config;
      const compositionKey = editor._compositionKey;
      const editable = editor._editable;
      if (exportDOM) {
        let htmlString = "";
        editorState.read(() => {
          htmlString = printPrettyHTML(html.$generateHtmlFromNodes(editor));
        });
        return htmlString;
      }
      let res = " root\n";
      const selectionString = editorState.read(() => {
        const selection = lexical.$getSelection();
        visitTree(lexical.$getRoot(), (node, indent) => {
          const nodeKey = node.getKey();
          const nodeKeyDisplay = `(${nodeKey})`;
          const typeDisplay = node.getType() || "";
          const isSelected = node.isSelected();
          const idsDisplay = mark.$isMarkNode(node) ? ` id: [ ${node.getIDs().join(", ")} ] ` : "";
          res += `${isSelected ? SYMBOLS.selectedLine : " "} ${indent.join(" ")} ${nodeKeyDisplay} ${typeDisplay} ${idsDisplay} ${printNode(node)}
`;
          res += printSelectedCharsLine({
            indent,
            isSelected,
            node,
            nodeKeyDisplay,
            selection,
            typeDisplay
          });
        });
        return selection === null ? ": null" : lexical.$isRangeSelection(selection) ? printRangeSelection(selection) : lexical.DEPRECATED_$isGridSelection(selection) ? printGridSelection(selection) : printNodeSelection(selection);
      });
      res += "\n selection" + selectionString;
      res += "\n\n commands:";
      if (commandsLog.length) {
        for (const {
          type,
          payload
        } of commandsLog) {
          res += `
  └ { type: ${type}, payload: ${payload instanceof Event ? payload.constructor.name : payload} }`;
        }
      } else {
        res += "\n  └ None dispatched.";
      }
      res += "\n\n editor:";
      res += `
  └ namespace ${editorConfig.namespace}`;
      if (compositionKey !== null) {
        res += `
  └ compositionKey ${compositionKey}`;
      }
      res += `
  └ editable ${String(editable)}`;
      return res;
    }
    function visitTree(currentNode, visitor, indent = []) {
      const childNodes = currentNode.getChildren();
      const childNodesLength = childNodes.length;
      childNodes.forEach((childNode, i) => {
        visitor(childNode, indent.concat(i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling));
        if (lexical.$isElementNode(childNode)) {
          visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling));
        }
      });
    }
    function normalize(text) {
      return Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, [key, value]) => acc.replace(new RegExp(key, "g"), String(value)), text);
    }
    function printNode(node) {
      if (lexical.$isTextNode(node)) {
        const text = node.getTextContent();
        const title = text.length === 0 ? "(empty)" : `"${normalize(text)}"`;
        const properties = printAllTextNodeProperties(node);
        return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(" ").trim();
      } else if (link.$isLinkNode(node)) {
        const link2 = node.getURL();
        const title = link2.length === 0 ? "(empty)" : `"${normalize(link2)}"`;
        const properties = printAllLinkNodeProperties(node);
        return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(" ").trim();
      } else {
        return "";
      }
    }
    var FORMAT_PREDICATES = [(node) => node.hasFormat("bold") && "Bold", (node) => node.hasFormat("code") && "Code", (node) => node.hasFormat("italic") && "Italic", (node) => node.hasFormat("strikethrough") && "Strikethrough", (node) => node.hasFormat("subscript") && "Subscript", (node) => node.hasFormat("superscript") && "Superscript", (node) => node.hasFormat("underline") && "Underline"];
    var DETAIL_PREDICATES = [(node) => node.isDirectionless() && "Directionless", (node) => node.isUnmergeable() && "Unmergeable"];
    var MODE_PREDICATES = [(node) => node.isToken() && "Token", (node) => node.isSegmented() && "Segmented"];
    function printAllTextNodeProperties(node) {
      return [printFormatProperties(node), printDetailProperties(node), printModeProperties(node)].filter(Boolean).join(", ");
    }
    function printAllLinkNodeProperties(node) {
      return [printTargetProperties(node), printRelProperties(node), printTitleProperties(node)].filter(Boolean).join(", ");
    }
    function printDetailProperties(nodeOrSelection) {
      let str = DETAIL_PREDICATES.map((predicate) => predicate(nodeOrSelection)).filter(Boolean).join(", ").toLocaleLowerCase();
      if (str !== "") {
        str = "detail: " + str;
      }
      return str;
    }
    function printModeProperties(nodeOrSelection) {
      let str = MODE_PREDICATES.map((predicate) => predicate(nodeOrSelection)).filter(Boolean).join(", ").toLocaleLowerCase();
      if (str !== "") {
        str = "mode: " + str;
      }
      return str;
    }
    function printFormatProperties(nodeOrSelection) {
      let str = FORMAT_PREDICATES.map((predicate) => predicate(nodeOrSelection)).filter(Boolean).join(", ").toLocaleLowerCase();
      if (str !== "") {
        str = "format: " + str;
      }
      return str;
    }
    function printTargetProperties(node) {
      let str = node.getTarget();
      if (str != null) {
        str = "target: " + str;
      }
      return str;
    }
    function printRelProperties(node) {
      let str = node.getRel();
      if (str != null) {
        str = "rel: " + str;
      }
      return str;
    }
    function printTitleProperties(node) {
      let str = node.getTitle();
      if (str != null) {
        str = "title: " + str;
      }
      return str;
    }
    function printSelectedCharsLine({
      indent,
      isSelected,
      node,
      nodeKeyDisplay,
      selection,
      typeDisplay
    }) {
      if (!lexical.$isTextNode(node) || !lexical.$isRangeSelection(selection) || !isSelected || lexical.$isElementNode(node)) {
        return "";
      }
      const anchor = selection.anchor;
      const focus = selection.focus;
      if (node.getTextContent() === "" || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {
        return "";
      }
      const [start, end] = $getSelectionStartEnd(node, selection);
      if (start === end) {
        return "";
      }
      const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;
      const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];
      const unselectedChars = Array(start + 1).fill(" ");
      const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);
      const paddingLength = typeDisplay.length + 3;
      const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(" ");
      return [SYMBOLS.selectedLine, indentionChars.join(" "), [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join("")].join(" ") + "\n";
    }
    function printPrettyHTML(str) {
      const div = document.createElement("div");
      div.innerHTML = str.trim();
      return prettifyHTML(div, 0).innerHTML;
    }
    function prettifyHTML(node, level) {
      const indentBefore = new Array(level++ + 1).join("  ");
      const indentAfter = new Array(level - 1).join("  ");
      let textNode;
      for (let i = 0; i < node.children.length; i++) {
        textNode = document.createTextNode("\n" + indentBefore);
        node.insertBefore(textNode, node.children[i]);
        prettifyHTML(node.children[i], level);
        if (node.lastElementChild === node.children[i]) {
          textNode = document.createTextNode("\n" + indentAfter);
          node.appendChild(textNode);
        }
      }
      return node;
    }
    function $getSelectionStartEnd(node, selection) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      const textContent = node.getTextContent();
      const textLength = textContent.length;
      let start = -1;
      let end = -1;
      if (anchor.type === "text" && focus.type === "text") {
        const anchorNode = anchor.getNode();
        const focusNode = focus.getNode();
        if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {
          [start, end] = anchor.offset < focus.offset ? [anchor.offset, focus.offset] : [focus.offset, anchor.offset];
        } else if (node === anchorNode) {
          [start, end] = anchorNode.isBefore(focusNode) ? [anchor.offset, textLength] : [0, anchor.offset];
        } else if (node === focusNode) {
          [start, end] = focusNode.isBefore(anchorNode) ? [focus.offset, textLength] : [0, focus.offset];
        } else {
          [start, end] = [0, textLength];
        }
      }
      const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;
      const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;
      return [start + numNonSingleWidthCharBeforeSelection, end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection];
    }
    exports.TreeView = TreeView;
  }
});

// node_modules/@lexical/react/LexicalTreeView.js
var require_LexicalTreeView = __commonJS({
  "node_modules/@lexical/react/LexicalTreeView.js"(exports, module) {
    var LexicalTreeView = true ? require_LexicalTreeView_dev() : null;
    module.exports = LexicalTreeView;
  }
});
export default require_LexicalTreeView();
//# sourceMappingURL=@lexical_react_LexicalTreeView.js.map
